## 树
- 概念
	+ 节点的度 degree
		* 子树的个数
	+ 树的度
		* 所有节点度的最大值
	+ 层数 level
		* 根节点在第一层，子节点在第二层，以此类推
	+ 节点深度 depth
		* 从根节点到当前节点的唯一路径上的节点总数
	+ 节点高度 height
		* 从当前节点到最远叶子节点路径上的节点总数
	+ 树深度（等于树的高度）
		* 所有节点深度最大值
	+ 树高度
		* 所有节点高度最大值
	+ 有序树
		* 树中任意节点的子节点之间有顺序关系
- 二叉树 Binary Tree
	+ 每个节点的度最大值为 2 的树
	+ 左子树和右子树是有顺序的
	+ 节点只有一棵子树，也要区分左右子树
	+ 非空二叉树的第n层，最多有 2 的 n-1 次方个节点
	+ 高度为 h 的二叉树，最多有 2 的 n 次方 -1 个节点
	+ 任一非空二叉树，如果叶子节点个数为 n0，度为2的节点个数为n2，n0=n2+1 (总边数相同)
- 真二叉树 Proper Binary Tree
	+ 所有节点的度要么为0 ，要么为 2
- 满二叉树 Full Binary Tree
	+ 真二叉树，同时满足所有叶子节点在最后一层
- 完全二叉树 Copmlete Binary Tree
	+ 叶子节点只出现在最后2层，除去最后一层为满二叉树，且最后一层叶子节点都靠左对齐
	+ 按照从上到下，从左到右排
- 节点数计算 总节点n
	+ 叶子节点 floor((n+1)/2)
	+ 非叶子节点 floor(n/2)
- 二叉搜索树 Binary Search Tree
	+ 任意一个节点的值，大于其左子树所有节点的值
	+ 任意一个节点的值，小于其右子树所有节点的值
- 二叉树遍历
	+ 前序遍历 根左右
	+ 中序遍历 左根右
		* 对二叉搜索树，中序结果是有序的，如从小到大
	+ 后序遍历 左右根
	+ 层序遍历 从上往下，从左到右依次遍历节点
- 二叉树删除节点
	+ 前驱节点 https://blog.csdn.net/IOSSHAN/article/details/108557848
		* 中序遍历时某个节点的前一个节点 
	+ 后继节点
		* 中序遍历时某个节点的后一个节点
	+ 如果一个节点度为2，其前驱后继节点度肯定是1或0
- 平衡二叉搜索树（Balanced Binary Search Tree） https://zhuanlan.zhihu.com/p/65424847
	+ 任意节点的子树的高度差都小于等于 1
	+ 左旋
		* 对X节点左旋，即以X的右孩子Y为轴，将X节点转下来，变为Y的左孩子
			- 左旋即把该节点变为左孩子
	+ 右旋
		* 对X节点右旋，即以X的左孩子Y为轴，将X节点转下来，变为Y的右孩子
			- 右旋即把该节点变为右孩子
	+ AVL 树 
		*  https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl-tree-go%E5%AE%9E%E7%8E%B0/
		*  https://blog.csdn.net/qq_43915356/article/details/106381560
		*  平衡因子（Balance Factor）：某结点的左右子树的高度差
		*  最小不平衡子树：距离插入节点最近的，并且 BF 的绝对值大于 1 的节点为根节点的子树
		*  每个节点的平衡因子只可能是 1、0、-1（绝对值 ≤ 1，如果超过 1，称之为“失衡”）
		*  每个节点的左右子树高度差不超过 1
		*  搜索、添加、删除的时间复杂度是 O(logn)
		*  LL 型失衡 右旋 
		*  RR 型失衡 左旋
		*  LR 型失衡 左孩子（最小不平衡子树）左旋，再根节点右旋
		*  RL 型失衡 右孩子（最小不平衡子树）右旋，再根节点左旋
	+ 红黑树 Red Black Tree
		* 每个节点要么是红色，要么是黑色
		* 根节点是黑色
		* 每个叶子节点（NIL节点，空节点）是黑色的
			- 用NiL节点保证所有节点度为2，但NIL节点不算真正的黑色节点，只作为树的终止标记
		* 如果一个节点是红色的，则它的两个子节点必须是黑色的
		* 从一个节点到叶子节点的所有路径上包含相同数目的黑节点
		* 添加 https://juejin.cn/post/7177716251215527997
			- 建议新添加的节点默认为 RED，这样能够让红黑树的性质尽快满足（性质 1、2、3、5 都满足，性质 4 不一定）
			- 如果添加的是根节点，染成 BLACK 即可
			- 有 4 种情况满足红黑树的性质
				+ parent 为 BLACK 满足 4阶B树 的性质，不用做任何额外处理
			- 有 8 种情况不满足红黑树的性质 4 ：parent 为 RED（ Double Red ）
				+ 其中前 4 种属于B树节点上溢的情况
- B树 B-Tree
	+ 一种平衡的多路搜索树，用于文件系统，数据库
	+ 一个节点可以存储超过2个子节点
	+ BBST的一些性质
	+ 平衡
	+ m阶的B树每个节点最多只有m个子节点（m-1个元素），最少有m/2个节点，m/2-1个元素，根节点最少一个
	+ 新添加的元素必然是叶子节点
- 红黑树与4阶B树具有等价性
	+ 黑节点与它的红色子节点融合形成一个B树节点
	+ 红黑树的黑节点个数与4阶B树节点总个数相等
- 红黑树 VS AVL
	+ AVL 平衡标准比较严格：每个左右子树的高度差不超过1
	+ 红黑树 平衡标准比较宽松：没有一条路径会大于其他路径的2倍
	+ 搜索的次数远远大于插入和删除，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树
	+ 相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树
- 二叉堆
	+ 任意节点的值总是不大于（或者不小于）子节点的值
	+ 其逻辑为一棵完全二叉树，故也叫完全二叉堆
	+ 底层一般采用数组实现（0 <= i <= n-1）
		* i=0,根节点
		* i>0，其父节点索引为floor((i-1)/2)
		* 如果2i+1 <= n-1，则其左子节点编号为2i+1，否则没有左节点
		* 如果2i+2 <= n-1，则其右子节点编号为2i+2，否则没有左节点
- 优先级队列 Priority Queue
	+ 按照优先级高低进行出队
	+ 二叉堆实现
- Trie 字典树/前缀树/单次查找树
	+ 搜索字符串的效率主要跟字符串的长度有关